{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Objective Seeking an interdisciplinary internship or co-op in building on my current strengths and experiential learning. Passionate about how Philosophy and Computer Science blend to solve real world problems. xxx yyy","title":"About Me"},{"location":"#objective","text":"Seeking an interdisciplinary internship or co-op in building on my current strengths and experiential learning. Passionate about how Philosophy and Computer Science blend to solve real world problems. xxx yyy","title":"Objective"},{"location":"about/","text":"Portfolio of Luke This is my portfolio. Java - Backend @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } } Stuff theme: features: - content.code.annotate # (1) Clojure - Backend (defn num-compare [row index] \"Compares the two numbers\" (if (= (nth row index) (nth row (+ index 1) nil)) (do (swap! score + (* 2 (nth row index 0))) (update (update row (+ index 1) #(* % 0)) index #(* % 2))) row)) 'Java' - Frontend stringRequest.setRetryPolicy(new RetryPolicy() { @Override public int getCurrentTimeout() { return 20000; } @Override public int getCurrentRetryCount() { return 40000; } @Override public void retry(VolleyError error) throws VolleyError {}});","title":"Portfolio of Luke"},{"location":"about/#portfolio-of-luke","text":"This is my portfolio.","title":"Portfolio of Luke"},{"location":"about/#java-backend","text":"@RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } }","title":"Java - Backend"},{"location":"about/#stuff","text":"theme: features: - content.code.annotate # (1)","title":"Stuff"},{"location":"about/#clojure-backend","text":"(defn num-compare [row index] \"Compares the two numbers\" (if (= (nth row index) (nth row (+ index 1) nil)) (do (swap! score + (* 2 (nth row index 0))) (update (update row (+ index 1) #(* % 0)) index #(* % 2))) row))","title":"Clojure - Backend"},{"location":"about/#java-frontend","text":"stringRequest.setRetryPolicy(new RetryPolicy() { @Override public int getCurrentTimeout() { return 20000; } @Override public int getCurrentRetryCount() { return 40000; } @Override public void retry(VolleyError error) throws VolleyError {}});","title":"'Java' - Frontend"},{"location":"myphilosophy/","text":"My Philosophy Philosophy Major + Computer Science Minor There is an underrated intersection between philosophy and computer science. Computer science is well-acclaimed in today's society, but not so much philosophy - a subject that in ancient times was incredibly well respected. After all, philosophy is mostly known nowadays for dealing in the theoretical, sometimes to an idealistic degree. So to put them together at first glance can seem downright unusual. However, when comparing the skillset and subject crossovers, one can be left wondering how such a clear parallel goes unnoticed. Philosophers are often self-selecting, choosing the subject as their curiosity for understanding or at least trying to understand the world around them is fascinating. They constantly question old and new philosophers' arguments, and even their own. In order to prove their arguments, validate or refute others, or even just to understand arguments, they learn to break down an argument down to its most essential forms. And with these forms, they know each have a relation with one another, and that even one bad relation or form can invalidate a whole argument. One can only imagine when Philosophers carry this desire to understand and explore the unknown into the realm of computer science, whether it be an area as broad and confusing artificial intelligence or something as specific as a micro-framework. Each of these forms arguments as abstract structures, that each part of the argument has some sort of connection and that weak connections form weak arguments. Yet when applying the curiosity, eagerness to learn, and ability to recognize argumentative structures, it's hard not to see how the Computer Science v Philosophy Skillset (Curiosity/Developing Mindset, Abstract Structures, Impossible Problems) Subject Crossover (Propositional Logic v Natural Language, Symbolic Logic v General Programming, Argument Forming v Function Programming) Famous Philosophy Majors in Tech","title":"My Philosophy"},{"location":"myphilosophy/#my-philosophy","text":"Philosophy Major + Computer Science Minor There is an underrated intersection between philosophy and computer science. Computer science is well-acclaimed in today's society, but not so much philosophy - a subject that in ancient times was incredibly well respected. After all, philosophy is mostly known nowadays for dealing in the theoretical, sometimes to an idealistic degree. So to put them together at first glance can seem downright unusual. However, when comparing the skillset and subject crossovers, one can be left wondering how such a clear parallel goes unnoticed. Philosophers are often self-selecting, choosing the subject as their curiosity for understanding or at least trying to understand the world around them is fascinating. They constantly question old and new philosophers' arguments, and even their own. In order to prove their arguments, validate or refute others, or even just to understand arguments, they learn to break down an argument down to its most essential forms. And with these forms, they know each have a relation with one another, and that even one bad relation or form can invalidate a whole argument. One can only imagine when Philosophers carry this desire to understand and explore the unknown into the realm of computer science, whether it be an area as broad and confusing artificial intelligence or something as specific as a micro-framework. Each of these forms arguments as abstract structures, that each part of the argument has some sort of connection and that weak connections form weak arguments. Yet when applying the curiosity, eagerness to learn, and ability to recognize argumentative structures, it's hard not to see how the Computer Science v Philosophy Skillset (Curiosity/Developing Mindset, Abstract Structures, Impossible Problems) Subject Crossover (Propositional Logic v Natural Language, Symbolic Logic v General Programming, Argument Forming v Function Programming) Famous Philosophy Majors in Tech","title":"My Philosophy"},{"location":"projects/","text":"Projects These are my projects. They highlight my experience with both object-oriented programming (OOP) and functional programming (FP) paradigms. They also demonstrate my full-stack experience with Python, Java, Clojure, or Rust. Full-Stack Clojure Web App with Python Interpreter My experimention with a frontend written in Clojure integrated with a backend Python interpreter Full-Stack Android/Java App (OOP) with Natural Language Processing (NLP) A Quizlet inspired flashcard application which uses NLP to generate questions Console App (FP) for 2048 game My first Clojure app using functional programming then later improved using macros Rust macro exploration of tail-call optimization A deeper exploration into macros, ASTs, and token parsing in Rust Developer Automation Tool for Clojure Shell command tools to automate installation of Clojure compiler","title":"Projects"},{"location":"projects/#projects","text":"These are my projects. They highlight my experience with both object-oriented programming (OOP) and functional programming (FP) paradigms. They also demonstrate my full-stack experience with Python, Java, Clojure, or Rust. Full-Stack Clojure Web App with Python Interpreter My experimention with a frontend written in Clojure integrated with a backend Python interpreter Full-Stack Android/Java App (OOP) with Natural Language Processing (NLP) A Quizlet inspired flashcard application which uses NLP to generate questions Console App (FP) for 2048 game My first Clojure app using functional programming then later improved using macros Rust macro exploration of tail-call optimization A deeper exploration into macros, ASTs, and token parsing in Rust Developer Automation Tool for Clojure Shell command tools to automate installation of Clojure compiler","title":"Projects"},{"location":"quizmain/","text":"Full-Stack Android/Java App (OOP) with Natural Language Processing (NLP) A Quizlet inspired flashcard application which uses NLP to generate questions * Aims to convert a declarative statement to a question for flashcard studying purposes Java Frontend with NLP for Android Sprint Boot Backend using GCP with NLP Project Highlights 1. Java - Natural Language Processing (NLP) Source: SentenceAnalyzer.java Gets the simplified version of an input stream, using Sentence Detection and Part-of-Speech (POS) tagging to aid in Lemmatization. Removes proper nouns, using built-in LinkedList functionality, which requires a traversal when unspecified, thus O(n) time complexity. public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; } 2. Java - API Response Source: QuizController.java Utilizes query parameters sent over from the frontend app to be analyzed with NLP, returning back a calculated response via a simple String @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } } 3. Java - OOP Polymorphism Source: SentenceAnalyzer.java Overrides default .equals() method. Using Natural Language Processing, measures sentence equality. For example: \"Joe walks and Joe walked\" would be ruled equal due to lemmatization (removing unessential parts of a word, like tense, to its base form). @Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } }","title":"Full-Stack Android/Java App (OOP) with Natural Language Processing (NLP)"},{"location":"quizmain/#full-stack-androidjava-app-oop-with-natural-language-processing-nlp","text":"A Quizlet inspired flashcard application which uses NLP to generate questions * Aims to convert a declarative statement to a question for flashcard studying purposes Java Frontend with NLP for Android Sprint Boot Backend using GCP with NLP","title":"Full-Stack Android/Java App (OOP) with Natural Language Processing (NLP)"},{"location":"quizmain/#project-highlights","text":"","title":"Project Highlights"},{"location":"quizmain/#1java-natural-language-processing-nlp","text":"Source: SentenceAnalyzer.java Gets the simplified version of an input stream, using Sentence Detection and Part-of-Speech (POS) tagging to aid in Lemmatization. Removes proper nouns, using built-in LinkedList functionality, which requires a traversal when unspecified, thus O(n) time complexity. public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; }","title":"1.Java - Natural Language Processing (NLP)"},{"location":"quizmain/#2-java-api-response","text":"Source: QuizController.java Utilizes query parameters sent over from the frontend app to be analyzed with NLP, returning back a calculated response via a simple String @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } }","title":"2. Java - API Response"},{"location":"quizmain/#3java-oop-polymorphism","text":"Source: SentenceAnalyzer.java Overrides default .equals() method. Using Natural Language Processing, measures sentence equality. For example: \"Joe walks and Joe walked\" would be ruled equal due to lemmatization (removing unessential parts of a word, like tense, to its base form). @Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } }","title":"3.Java - OOP Polymorphism"},{"location":"projects/gist/","text":"Developer Automation Tool for Clojure Source: Github Gist link This problem occurred to me in high school, when we were allowed to borrow school computers from the library. Not knowing the password but wanting to program during my free periods in Clojure, it required me admin access to run install commands such as homebrew. To get around this, I used a similar technique to install pip3 that I had used before, taking advantage of the .bashrc profile while grabbing a self-install script. 1. Make a new directory called \"bin\" in the home (~) folder : mkdir ~/bin 2. Download the self-install script for Leiningen : curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein -o ~/bin 3. Create your .bashrc file if not already created : touch ~/.bashrc 4. Edit the path in your favorite editor to : PATH=$PATH:~/bin 5. Confirm the changed path using the command : source ~/.bashrc 6. Test out the newly installed Leiningen with : lein new app hello-world","title":"Developer Automation Tool for Clojure"},{"location":"projects/gist/#developer-automation-tool-for-clojure","text":"Source: Github Gist link This problem occurred to me in high school, when we were allowed to borrow school computers from the library. Not knowing the password but wanting to program during my free periods in Clojure, it required me admin access to run install commands such as homebrew. To get around this, I used a similar technique to install pip3 that I had used before, taking advantage of the .bashrc profile while grabbing a self-install script. 1. Make a new directory called \"bin\" in the home (~) folder : mkdir ~/bin 2. Download the self-install script for Leiningen : curl https://raw.githubusercontent.com/technomancy/leiningen/stable/bin/lein -o ~/bin 3. Create your .bashrc file if not already created : touch ~/.bashrc 4. Edit the path in your favorite editor to : PATH=$PATH:~/bin 5. Confirm the changed path using the command : source ~/.bashrc 6. Test out the newly installed Leiningen with : lein new app hello-world","title":"Developer Automation Tool for Clojure"},{"location":"projects/quizback/","text":"Sprint Boot Backend using GCP with NLP Source: Github Link Java - Natural Language Processing (NLP) Source: SentenceAnalyzer.java Gets the simplified version of an input stream, using Sentence Dectection and Part-of-Speech (POS) tagging to aid in Lemmatization. Removes proper nouns, using built-in LinkedList functionality, which requires a traversal when unspecified, thus O(n) time complexity. public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; } Java - API Response Source: QuizController.java Utilizes query parameters sent over from the frontend app to be analyzed with NLP, returning back a calculated response via a simple String @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } } Java - Dynamic Polymorphism Source: SentenceAnalyzer.java Overrides default .equals() method. Using Natural Language Processing, measures sentence equality. For example: \"Joe walks and Joe walked\" would be ruled equal due to lemmatization (removing unessential parts of a word, like tense, to its base form). @Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } } private int findEndOfPhrase(final Span[] spans, int acc) { int phraseEndIndex = 0; while (!spans[acc].getType().equals(\"VP\")) { phraseEndIndex = spans[acc].getEnd(); acc++; if (acc >= spans.length) { return -1; } } while (!spans[acc].getType().equals(\"NP\")) { phraseEndIndex = spans[acc].getEnd(); acc++; if (acc >= spans.length) { return -1; } } return phraseEndIndex; }","title":"Sprint Boot Backend using GCP with NLP"},{"location":"projects/quizback/#sprint-boot-backend-using-gcp-with-nlp","text":"Source: Github Link","title":"Sprint Boot Backend using GCP with NLP"},{"location":"projects/quizback/#java-natural-language-processing-nlp","text":"Source: SentenceAnalyzer.java Gets the simplified version of an input stream, using Sentence Dectection and Part-of-Speech (POS) tagging to aid in Lemmatization. Removes proper nouns, using built-in LinkedList functionality, which requires a traversal when unspecified, thus O(n) time complexity. public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; }","title":"Java - Natural Language Processing (NLP)"},{"location":"projects/quizback/#java-api-response","text":"Source: QuizController.java Utilizes query parameters sent over from the frontend app to be analyzed with NLP, returning back a calculated response via a simple String @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } }","title":"Java - API Response"},{"location":"projects/quizback/#java-dynamic-polymorphism","text":"Source: SentenceAnalyzer.java Overrides default .equals() method. Using Natural Language Processing, measures sentence equality. For example: \"Joe walks and Joe walked\" would be ruled equal due to lemmatization (removing unessential parts of a word, like tense, to its base form). @Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } } private int findEndOfPhrase(final Span[] spans, int acc) { int phraseEndIndex = 0; while (!spans[acc].getType().equals(\"VP\")) { phraseEndIndex = spans[acc].getEnd(); acc++; if (acc >= spans.length) { return -1; } } while (!spans[acc].getType().equals(\"NP\")) { phraseEndIndex = spans[acc].getEnd(); acc++; if (acc >= spans.length) { return -1; } } return phraseEndIndex; }","title":"Java - Dynamic Polymorphism"},{"location":"projects/quizmaster/","text":"Sprint Boot Backend using GCP with NLP Source: Github Link Java - Lemmatizer (NLP) public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; } Java - Dynamic Polymorphism @Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } } Java - API Response @RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } }","title":"Sprint Boot Backend using GCP with NLP"},{"location":"projects/quizmaster/#sprint-boot-backend-using-gcp-with-nlp","text":"Source: Github Link","title":"Sprint Boot Backend using GCP with NLP"},{"location":"projects/quizmaster/#java-lemmatizer-nlp","text":"public List<String> getTrueMeanings() throws IOException { InputStream stream = new ClassPathResource(\"en-lemmatizer.dict\").getInputStream(); DictionaryLemmatizer lem = new DictionaryLemmatizer(stream); List<String> lemmas = new LinkedList<String> (Arrays.asList(lem.lemmatize(detectSentence(), partOfSpeechTags()))); lemmas.remove(new String(\"O\")); return lemmas; }","title":"Java - Lemmatizer (NLP)"},{"location":"projects/quizmaster/#java-dynamic-polymorphism","text":"@Override public boolean equals(Object o) { // Idea : create a model that analyzes the similarity between answers if (o == this) { return true; } else if (o == null || !(o instanceof SentenceAnalyzer)) { return false; } SentenceAnalyzer analyzer = (SentenceAnalyzer) o; try { return analyzer.getTrueMeanings().equals(this.getTrueMeanings()); } catch (IOException exception) { System.out.println(\"IOException found: \" + exception); return false; } }","title":"Java - Dynamic Polymorphism"},{"location":"projects/quizmaster/#java-api-response","text":"@RequestMapping(value = \"/process/{questionId}\", method = RequestMethod.GET) public String process(@PathVariable int questionId) throws IOException { Resource quiz = getQuestion(questionId); String input = StreamUtils.copyToString( quiz.getInputStream(), Charset.defaultCharset()); SentenceAnalyzer analyzer = new SentenceAnalyzer(input); try { String output = analyzer.setUpQuestion(analyzer.detectSentence()); return output; } catch (Exception e) { e.printStackTrace(); return \"\"; } } }","title":"Java - API Response"},{"location":"projects/snofin/","text":"Full-Stack Clojure Web App with Python Interpreter Source: Github Link This project was inspired by my initial discovery of the GraalVM (a Java VM and JDK). I had discovered GraalVM after learning the basics of token parsing and abstract syntax trees (AST) from creating Rust macros. GraalVM uses Truffle , which is a Java library that utilizes ASTs and aims to allow interopability between programming languages. Because of this, I sought out this mini project, to see how simple it is to execute python shell commands in Clojure, thus creating this app. I chose Python because for my computer science club, that was the language that many kids aimed to learn. (defn- execute-python! [msg] \"Runs a python shell\" (let [result (shell/sh \"python\" \"-c\" (json->clj msg))] (if (str/blank? (:err result)) (do (doseq [result (str/split (:out result) #\"\\n\") channel @channels] (send! channel (clj->json result)))) (do (doseq [channel @channels] (send! channel (error->json (:err result)))))))) (defn home-page [{:keys [message]}] [:div.container [:div.row [:div.col-md-12 [:center [:h3 \"Exercise 1: Print out the number 100\"]]]] [:div.row [:div.col-sm-6]] [:div.row [:div.row>div.col-sm-12 [message-input] [:center [:button.btn.btn-primary {:on-click #(do (ws/send-transit-msg! {:message @value}) (reset! messages nil) (reset! output @value)) :style {:font-size \"50px\"}} \"Execute the Python Script\"] [:h3 \"Output\"] (for [x @messages] [:h2 x]) ] ]]]) (defn- json->clj [msg] \"Converts a JSON-encoded map into a clojure string (clojure.java.string)\" (as-> msg result (.getBytes result) (java.io.ByteArrayInputStream. result) (clojure.java.io/input-stream result) (transit/reader result :json) (transit/read result) (:message result)))","title":"Full-Stack Clojure Web App with Python Interpreter"},{"location":"projects/snofin/#full-stack-clojure-web-app-with-python-interpreter","text":"Source: Github Link This project was inspired by my initial discovery of the GraalVM (a Java VM and JDK). I had discovered GraalVM after learning the basics of token parsing and abstract syntax trees (AST) from creating Rust macros. GraalVM uses Truffle , which is a Java library that utilizes ASTs and aims to allow interopability between programming languages. Because of this, I sought out this mini project, to see how simple it is to execute python shell commands in Clojure, thus creating this app. I chose Python because for my computer science club, that was the language that many kids aimed to learn. (defn- execute-python! [msg] \"Runs a python shell\" (let [result (shell/sh \"python\" \"-c\" (json->clj msg))] (if (str/blank? (:err result)) (do (doseq [result (str/split (:out result) #\"\\n\") channel @channels] (send! channel (clj->json result)))) (do (doseq [channel @channels] (send! channel (error->json (:err result)))))))) (defn home-page [{:keys [message]}] [:div.container [:div.row [:div.col-md-12 [:center [:h3 \"Exercise 1: Print out the number 100\"]]]] [:div.row [:div.col-sm-6]] [:div.row [:div.row>div.col-sm-12 [message-input] [:center [:button.btn.btn-primary {:on-click #(do (ws/send-transit-msg! {:message @value}) (reset! messages nil) (reset! output @value)) :style {:font-size \"50px\"}} \"Execute the Python Script\"] [:h3 \"Output\"] (for [x @messages] [:h2 x]) ] ]]]) (defn- json->clj [msg] \"Converts a JSON-encoded map into a clojure string (clojure.java.string)\" (as-> msg result (.getBytes result) (java.io.ByteArrayInputStream. result) (clojure.java.io/input-stream result) (transit/reader result :json) (transit/read result) (:message result)))","title":"Full-Stack Clojure Web App with Python Interpreter"},{"location":"projects/tailcall/","text":"Rust macro exploration of tail-call optimization Rust - Using Function-Like Macros with Tokens - Backend Source: GitHub link This attempt was after learning about Clojure macros . Inspired by them, upon learning the basics of the systems language Rust, I set out to utilize their macros, wanting to compare the two. There are 3 different kinds of macros in Rust, and I found the function-like one the most appropriate for the given task : tail-call optimization. The macro works by stripping down the function passed into it by its most essentially parts, which is the function name, parameters and their respective types, the function body, and lastly the return type. Taking influence from learning dynamic programming from Clojure, I sought to take utilize memoization. I rearranged the function passed in, pointing the return value into a variable called '_memoize'. This value in theory would be stored for the next loop, where recursion was mocked. I had hoped this would prevent stuff from being added to the stack. Although this compiled and returned the correct value, there were several key flaws in it that proved unsolvable. Regardless, it was a great learning experience and introduced me to the world of token parsing and Abstract Syntax Trees (ASTs). macro_rules! recur_fn { ($fpointer:ident ($($pname:ident : $type:ty),*) -> $rtrn_type:ty $fbody:block) => (fn $fpointer ($($pname : $type),*) -> $rtrn_type { let mut _memoize = (true,$($pname),*); while _memoize.0 { fn recur (repeat:bool,$($pname:$type),*) -> (bool,$($type),*) {(true,$($pname),*)} _memoize = {$fbody}; } fn arb_fn ($($pname : $type),*) -> $rtrn_type {$fbody} }); }","title":"Rust macro exploration of tail-call optimization"},{"location":"projects/tailcall/#rust-macro-exploration-of-tail-call-optimization","text":"","title":"Rust macro exploration of tail-call optimization"},{"location":"projects/tailcall/#rust-using-function-like-macros-with-tokens-backend","text":"Source: GitHub link This attempt was after learning about Clojure macros . Inspired by them, upon learning the basics of the systems language Rust, I set out to utilize their macros, wanting to compare the two. There are 3 different kinds of macros in Rust, and I found the function-like one the most appropriate for the given task : tail-call optimization. The macro works by stripping down the function passed into it by its most essentially parts, which is the function name, parameters and their respective types, the function body, and lastly the return type. Taking influence from learning dynamic programming from Clojure, I sought to take utilize memoization. I rearranged the function passed in, pointing the return value into a variable called '_memoize'. This value in theory would be stored for the next loop, where recursion was mocked. I had hoped this would prevent stuff from being added to the stack. Although this compiled and returned the correct value, there were several key flaws in it that proved unsolvable. Regardless, it was a great learning experience and introduced me to the world of token parsing and Abstract Syntax Trees (ASTs). macro_rules! recur_fn { ($fpointer:ident ($($pname:ident : $type:ty),*) -> $rtrn_type:ty $fbody:block) => (fn $fpointer ($($pname : $type),*) -> $rtrn_type { let mut _memoize = (true,$($pname),*); while _memoize.0 { fn recur (repeat:bool,$($pname:$type),*) -> (bool,$($type),*) {(true,$($pname),*)} _memoize = {$fbody}; } fn arb_fn ($($pname : $type),*) -> $rtrn_type {$fbody} }); }","title":"Rust - Using Function-Like Macros with Tokens  - Backend"},{"location":"projects/x2048/","text":"Console App (FP) for 2048 game Source: Github Link Clojure - The Power of Clojure Macros This uses macros , which in Clojure, aid as a powerful tool of extension. For this macro, it is used for the game 2048. In order, to calculate the board from user input, it is quite often rotated and flattened from 2D to 1D form. A change is this implemented in a particular square in this form. Then, the board must be brought back to its original 2D form, and rotated back, in that particular order. Thus, this macro serves to rotate, then flatten, initiate a change, unflatten, and rotate in the opposite direction, taking functions as passed in parameters for evaluation to achieve this feat. In short: This macro prevents having to call rotate, flatten, single element change, unflatten, and rotate in reverse methods for different scenarios. This works ubiquitously in any rotated positioning. (defmacro back-and-forth \"Powerful macro that returns the grid to its natural state after rotating it\" ([f1 f2] `(->> (grid-2d) ~@f1 ~@f2 (shift-grid) ~@f2 ~@f1 (flatten))))","title":"Console App (FP) for 2048 game"},{"location":"projects/x2048/#console-app-fp-for-2048-game","text":"Source: Github Link","title":"Console App (FP) for 2048 game"},{"location":"projects/x2048/#clojure-the-power-of-clojure-macros","text":"This uses macros , which in Clojure, aid as a powerful tool of extension. For this macro, it is used for the game 2048. In order, to calculate the board from user input, it is quite often rotated and flattened from 2D to 1D form. A change is this implemented in a particular square in this form. Then, the board must be brought back to its original 2D form, and rotated back, in that particular order. Thus, this macro serves to rotate, then flatten, initiate a change, unflatten, and rotate in the opposite direction, taking functions as passed in parameters for evaluation to achieve this feat. In short: This macro prevents having to call rotate, flatten, single element change, unflatten, and rotate in reverse methods for different scenarios. This works ubiquitously in any rotated positioning. (defmacro back-and-forth \"Powerful macro that returns the grid to its natural state after rotating it\" ([f1 f2] `(->> (grid-2d) ~@f1 ~@f2 (shift-grid) ~@f2 ~@f1 (flatten))))","title":"Clojure - The Power of Clojure Macros"}]}